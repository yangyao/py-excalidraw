name: Deploy py-excalidraw

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      excalidraw_repo:
        description: Excalidraw repo URL used at build time
        required: false
        default: https://github.com/excalidraw/excalidraw.git
      excalidraw_ref:
        description: Excalidraw git ref (branch/tag/commit)
        required: false
        default: master

env:
  IMAGE_NAME: excalidraw-fastapi:latest
  REMOTE_DIR: /opt/py-excalidraw
  DEPLOY_TMP: /tmp/py-excalidraw-deploy

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Validate origins
        run: |
          if [ -z "${{ secrets.PUBLIC_ORIGIN }}" ]; then
            echo "PUBLIC_ORIGIN secret is required (Settings → Secrets and variables → Actions)." >&2
            exit 1
          fi

      - name: Build Docker image
        run: |
          # Build amd64 image so it runs on typical x86 servers
          docker buildx build \
            --platform linux/amd64 \
            --build-arg EXCALIDRAW_REPO="${{ inputs.excalidraw_repo || 'https://github.com/excalidraw/excalidraw.git' }}" \
            --build-arg EXCALIDRAW_REF="${{ inputs.excalidraw_ref || 'master' }}" \
            --build-arg PUBLIC_ORIGIN="${{ secrets.PUBLIC_ORIGIN }}" \
            --build-arg WS_ORIGIN="${{ secrets.WS_ORIGIN || secrets.PUBLIC_ORIGIN }}" \
            -t "$IMAGE_NAME" \
            --load \
            .

      - name: Save Docker image
        run: docker save "$IMAGE_NAME" | gzip > image.tar.gz

      - name: Prepare upload bundle
        run: |
          mkdir -p upload
          cp docker-compose.yml upload/
          mv image.tar.gz upload/

      - name: Upload files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          source: "upload/*"
          target: "${{ env.DEPLOY_TMP }}/"

      - name: Deploy on server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            set -euo pipefail
            REMOTE_DIR="${{ env.REMOTE_DIR }}"
            DEPLOY_TMP="${{ env.DEPLOY_TMP }}"

            sudo mkdir -p "$REMOTE_DIR" "$REMOTE_DIR/data"
            sudo chown -R "$USER":"$USER" "$REMOTE_DIR"

            echo "Contents of $DEPLOY_TMP before staging:"
            ls -la "$DEPLOY_TMP" || true
            if [ -d "$DEPLOY_TMP/upload" ]; then
              echo "Found nested upload directory; flattening…"
              mv -f "$DEPLOY_TMP"/upload/* "$DEPLOY_TMP"/ || true
              rmdir "$DEPLOY_TMP/upload" || true
              echo "Contents of $DEPLOY_TMP after flatten:"
              ls -la "$DEPLOY_TMP" || true
            fi

            # Update docker-compose.yml
            if [ -f "$DEPLOY_TMP/docker-compose.yml" ]; then
              mv -f "$DEPLOY_TMP/docker-compose.yml" "$REMOTE_DIR/docker-compose.yml"
            elif [ -f "$DEPLOY_TMP/upload/docker-compose.yml" ]; then
              mv -f "$DEPLOY_TMP/upload/docker-compose.yml" "$REMOTE_DIR/docker-compose.yml"
            else
              echo "docker-compose.yml not found in $DEPLOY_TMP" >&2
            fi

            # Load Docker image
            if [ -f "$DEPLOY_TMP/image.tar.gz" ]; then
              gunzip -c "$DEPLOY_TMP/image.tar.gz" | docker load
            elif [ -f "$DEPLOY_TMP/upload/image.tar.gz" ]; then
              gunzip -c "$DEPLOY_TMP/upload/image.tar.gz" | docker load
            else
              echo "image.tar.gz not found in $DEPLOY_TMP; proceeding if image already exists" >&2
            fi

            # Pick docker compose command
            if command -v docker-compose >/dev/null 2>&1; then
              DC="docker-compose"
            elif docker compose version >/dev/null 2>&1; then
              DC="docker compose"
            else
              echo "docker-compose or docker compose is required on server" >&2
              exit 1
            fi

            cd "$REMOTE_DIR"
            # Export runtime env vars for compose
            export APP_PUBLIC_ORIGIN='${{ secrets.PUBLIC_ORIGIN }}'
            # Quick sanity check for compose file presence
            ls -la "$REMOTE_DIR"
            if [ ! -f "$REMOTE_DIR/docker-compose.yml" ]; then
              echo "Compose file missing at $REMOTE_DIR/docker-compose.yml" >&2
              exit 1
            fi
            # Use explicit compose file path and avoid rebuilding on server
            $DC -f "$REMOTE_DIR/docker-compose.yml" up -d --no-build
            echo "Compose services status:"
            $DC -f "$REMOTE_DIR/docker-compose.yml" ps || true
            echo "Docker containers (including exited):"
            docker ps -a --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}' | sed -n '1,50p' || true

      - name: Deployment status
        if: always()
        run: echo "Deployment ${{ job.status }}"
